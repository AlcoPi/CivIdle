/// <reference types="react" />
import type { DisplayObject, IPointData } from "pixi.js";
import type { PartialSet, PartialTabulate } from "./TypeDefinitions";
export declare const SECOND = 1000;
export declare const MINUTE: number;
export declare const HOUR: number;
export declare const DAY: number;
export declare function escapeHtml(unsafe: string): string;
export declare function formatNumber(num: number | undefined | null, binary?: boolean, scientific?: boolean): string;
export declare function round(num: number, decimal: number): number;
export declare function formatPercent(p: number, decimal?: number): string;
export declare function keysOf<T extends {}>(obj: T): Array<keyof T>;
export declare function forEach<T extends {}>(obj: T | undefined, func: (k: keyof T, v: NonNullable<T[keyof T]>) => boolean | void): void;
export declare function firstKeyOf<T extends {}>(obj: T | undefined): Extract<keyof T, string> | null;
export declare function mFirstKeyOf<K, V>(obj: Map<K, V> | undefined): K | null;
export declare function firstValueOf<T extends {}>(obj: T | undefined): T[Extract<keyof T, string>] | null;
export declare function anyOf<T extends {}>(obj: T | undefined, func: (k: keyof T, v: NonNullable<T[keyof T]>) => boolean): boolean;
export declare function reduceOf<T extends {}, K>(obj: T | undefined, func: (prev: K, k: keyof T, v: NonNullable<T[keyof T]>) => K, initial: K): K;
export declare function mReduceOf<T, V, K>(obj: Map<T, V>, func: (prev: K, k: T, v: V) => K, initial: K): K;
export declare function safeAdd<T extends string>(obj: Partial<Record<T, number>>, key: T, valueToAdd: number): void;
export declare function mapSafeAdd<T>(obj: Map<T, number>, key: T, valueToAdd: number): void;
export declare function safePush<T extends string, K>(obj: Partial<Record<T, K[]>>, key: T, valueToPush: K): void;
export declare function mapSafePush<T, K>(obj: Map<T, K[]>, key: T, valueToPush: K): void;
export declare function mapOf<K extends string, V, T>(obj: Partial<Record<K, V>> | undefined | null, func: (key: K, value: V) => T, ifEmpty?: () => T[]): T[];
export declare function mMapOf<K, V, T>(obj: Map<K, V> | undefined | null, func: (key: K, value: V) => T, ifEmpty?: () => T[]): T[];
export declare function transformOf<K extends string, V, T>(obj: Partial<Record<K, V>>, func: (key: K, value: V) => T, ifEmpty?: () => Partial<Record<K, T>>): Partial<Record<K, T>>;
export declare function filterOf<K extends string, V>(obj: Partial<Record<K, V>>, func: (key: K, value: V) => boolean): Partial<Record<K, V>>;
export declare function mFilterOf<K, V>(obj: Map<K, V>, func: (key: K, value: V) => boolean): Map<K, V>;
export declare function jsxMapOf<K extends string, V>(obj: Partial<Record<K, V>> | undefined, func: (key: K, value: V) => JSX.Element[] | JSX.Element | null, ifEmpty?: () => JSX.Element | null): JSX.Element[] | JSX.Element | null;
export declare function jsxMMapOf<K, V>(obj: Map<K, V> | undefined, func: (key: K, value: V) => JSX.Element[] | JSX.Element | null, ifEmpty?: () => JSX.Element | null): JSX.Element[] | JSX.Element | null;
export declare function pointToXy(point: IPointData): string;
export declare function pointToTile(point: IPointData): Tile;
export declare function tileToPoint(tile: Tile): IPointData;
export declare function sizeOf(obj: any): number;
export type Tile = number;
export declare function xyToTile(xy: string): Tile;
export declare function tileToHash(xy: Tile): number;
export declare function xyToPoint(str: string): IPointData;
export declare function clamp(value: number, minInclusive: number, maxInclusive: number): number;
export declare function lerp(a: number, b: number, amount: number): number;
export declare function lookAt(displayObject: DisplayObject, point: IPointData): void;
export declare function layoutCenter(itemSize: number, margin: number, totalCount: number, current: number): number;
export type NumericKeyOf<TP> = {
    [P in keyof TP]: TP[P] extends number ? P : never;
}[keyof TP];
export type BooleanKeyOf<TP> = {
    [P in keyof TP]: TP[P] extends boolean ? P : never;
}[keyof TP];
export declare function sum<T>(arr: T[], key: NumericKeyOf<T>): number;
export declare function setContains<T extends string>(a: PartialSet<T>, b: PartialSet<T>): boolean;
export declare function tabulateAdd<T extends string>(...params: Array<PartialTabulate<T>>): PartialTabulate<T>;
export declare function safeParseInt(str: string, fallback?: number): number;
export declare function alphaNumericOf(str: string): string;
export declare function isAlphaNumeric(str: string): boolean;
export declare function containsNonASCII(str: string): boolean;
export declare function shuffle<T>(array: T[], rand?: () => number): T[];
export declare function isEmpty<K, V>(obj: Map<K, V> | Set<K> | object | null | undefined): boolean;
export declare function numberToRoman(num: number): string | null;
export declare function romanToNumber(str: string): number | null;
export declare function loadScript(src: string): Promise<void>;
export declare function deepFreeze<T>(object: T): Readonly<T>;
export declare function resolveIn<T>(seconds: number, result: T): Promise<T>;
export declare function rejectIn<T>(seconds: number, reason?: string): Promise<T>;
export declare function schedule<T>(func: () => T): Promise<T>;
export declare function getHMS(t: number): [number, number, number];
export declare function formatHMS(t: number): string;
export declare function formatHM(t: number): string;
interface ICanDrawLine {
    moveTo(x: number, y: number): this;
    lineTo(x: number, y: number): this;
}
export declare function drawDashedLine(g: ICanDrawLine, start: IPointData, end: IPointData, initial?: number, lineLength?: number, spaceLength?: number): number;
export declare function isNullOrUndefined(v: any): v is undefined | null;
export declare function hasFlag<T extends number>(value: T, flag: T): boolean;
export declare function setFlag<T extends number>(value: T, flag: T): T;
export declare function clearFlag<T extends number>(value: T, flag: T): T;
export declare function toggleFlag<T extends number>(value: T, flag: T): T;
export declare function copyFlag<T extends number>(from: T, to: T, flag: T): T;
export declare function base64ToBytes(base64: string): Uint8Array;
export declare function bytesToBase64(bytes: Uint8Array): string;
export declare function filterInPlace<T>(a: T[], condition: (v: T, i: number, array: T[]) => boolean): T[];
export {};
//# sourceMappingURL=Helper.d.ts.map